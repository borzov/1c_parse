# Контекст проекта: Анализатор выписок 1С

## 1. Назначение и Цель

Этот Python-скрипт предназначен для автоматического анализа банковских выписок в формате 1С (`1CClientBankExchange`, файлы `.txt`).

**Основная задача:** Обработать одну или несколько выписок (потенциально по разным юридическим лицам/счетам), агрегировать данные по контрагентам, нормализовать их наименования, определить ОПФ и сгенерировать два интерактивных HTML-отчета для анализа финансовых потоков.

**Решаемая проблема:** Автоматизация рутинного анализа множества выписок 1С, часто имеющих небольшие различия в формате и содержащих "грязные" данные по контрагентам.

## 2. Структура Проекта
├── data/ # Папка для входных файлов выписок (*.txt)
├── reports/ # Папка для выходных HTML-отчетов и отладочных CSV/TXT
├── src/ # Исходный код
│ ├── init.py # Пустой, для обозначения пакета
│ ├── main.py # Точка входа, оркестрация, настройка логирования
│ ├── config.py # Конфигурационные константы (пути, кодировка, режим отладки)
│ ├── normalization.py # Логика нормализации имен, определения ОПФ, форматирования ФИО
│ ├── parser_1c.py # Парсер файлов формата 1CClientBankExchange
│ ├── processing.py # Основная логика обработки: определение организаций, обработка транзакций, генерация отладки
│ ├── reporting.py # Агрегация данных для отчетов, рендеринг Jinja2 шаблонов
│ └── utils.py # Вспомогательные утилиты (парсинг дат, сумм, форматирование)
├── templates/ # HTML-шаблоны Jinja2
│ ├── report_annual_template.html # Шаблон годового отчета
│ └── report_comparison_template.html # Шаблон отчета сравнения
├── venv/ # Виртуальное окружение (если используется)
├── README.md # Описание проекта для пользователя
└── PROJECT_CONTEXT.md # Этот файл (технический контекст для ИИ/разработчика)


## 3. Ключевые Зависимости и Запуск

*   **Python:** 3.9+
*   **Библиотеки:** `Jinja2` (устанавливается через `pip install Jinja2`)
*   **Запуск:** Из корневой папки проекта командой `python -m src`.

## 4. Основная Логика и Алгоритмы

### 4.1. Парсинг (`src/parser_1c.py`)

*   Читает `.txt` файлы из `data/` в кодировке `FILE_ENCODING` (из `config.py`).
*   Разбирает файл по строкам, ищет секции `СекцияДокумент=...`.
*   Извлекает заголовок (`header_info`) и список документов (`documents`).
*   Определяет `ОсновнойСчетФайла` из заголовка или данных документа.
*   Добавляет `СчетФайла` и `_filepath` к каждому словарю документа.

### 4.2. Определение Организаций (`src/processing.py::detect_organizations`)

*   **Цель:** Создать словарь `our_orgs_map`, где ключ - расчетный счет нашей организации, значение - словарь с ее данными (`name`, `normalized`, `legal_form`, `inn`).
*   **Двухпроходный алгоритм:**
    1.  **Проход 1:** Для каждого *уникального* `ОсновнойСчетФайла` пытается найти имя организации (как плательщика или получателя с этим счетом) внутри *этого же* файла. Использует `normalize_and_classify` для очистки имени и определения ОПФ/ИНН. Если имя не найдено или не нормализовалось, счет попадает в список `needing_names`.
    2.  **Проход 2:** Для счетов из `needing_names` ищет *все* упоминания имени и ИНН (как плательщика или получателя) во *всех* документах из *всех* файлов. Выбирает самое частое/лучшее имя (`get_best_name`), пытается нормализовать его снова. Если успешно - добавляет в `detected_orgs`, иначе использует дефолтное имя.

### 4.3. Обработка Транзакций (`src/processing.py::process_documents`)

*   Итерирует по *всем* документам из *всех* файлов.
*   Определяет участников (`p_acc`, `r_acc`, `p_name_raw`, `r_name_raw`).
*   Определяет, кто из участников является "нашей" организацией (`is_p_ours`, `is_r_ours`) сверкой с `our_orgs_map`.
*   **Фильтрация:**
    *   Пропускает транзакции, где ни один участник не наш (`skipped_no_our_org`).
    *   Пропускает внутренние переводы (`is_p_ours and is_r_ours`) (`skipped_internal`).
*   **Определение типа и контрагента:**
    *   Определяет тип (`income`/`expense`) на основе совпадения `СчетФайла` с `p_acc` или `r_acc`.
    *   Обрабатывает случай несовпадения `СчетФайла` (пытается определить тип по тому, кто из участников является нашей организацией). Если определить не удается - пропускает (`skipped_mismatch`).
    *   Определяет данные нашей организации (`our_details`, `our_acc`) и сырые данные контрагента (`cp_raw`, `cp_inn`, `cp_acc`).
    *   Пропускает, если не найдены детали нашей организации (`skipped_details_missing`) или нет имени контрагента (`skipped_no_cp_name`).
*   **Валидация Даты/Суммы:** Парсит дату (`parse_date`), сумму (`safe_float`). Пропускает при невалидных значениях (`skipped_invalid_data`).
*   **Нормализация Контрагента:**
    *   Вызывает `normalize_and_classify(cp_raw, cp_inn)` для получения `cp_norm`, `cp_legal_form`.
*   **Генерация ID Контрагента (`cp_id`):**
    *   Приоритет: `INN:{cp_inn_clean}` (если ИНН валиден).
    *   Fallback: `NAME_ACC:{NAME_PART}|{ACC_PART}`, где `NAME_PART` - это `cp_norm.upper()` или `cp_raw_original.upper()` (если `cp_norm` равен '?'), `ACC_PART` - счет или "БЕЗ_СЧЕТА".
*   **Формирование `processed_transactions`:** Создает словарь с очищенными и структурированными данными для каждой валидной транзакции.
*   **Отладка:** Если `DEBUG_MODE=True`, заполняет списки `DEBUG_NAMES_LIST` и `DEBUG_TRANSACTIONS_LIST`.

### 4.4. Нормализация Имен (`src/normalization.py`)

*   **`detect_final_legal_form`:** Определяет ОПФ по ключевым словам (`LEGAL_FORMS_KEYWORDS`, `COMPILED_LEGAL_FORMS_FIND`), затем по длине ИНН, затем по структуре ФИО. Возвращает строку ОПФ ('ИП', 'ООО', 'ФЛ', 'ЮЛ', 'ДРУГОЕ'...).
*   **`normalize_name_core`:**
    *   Применяет список регулярных выражений для удаления "мусора" (`TRASH_PATTERNS_SPECIFIC`). **Важно:** эти правила могут быть слишком агрессивными и требовать доработки (как было с правилом для адресов).
    *   Удаляет ОПФ (если передана `detected_form`), сначала префикс 'ИП ', затем ищет другие формы как отдельные слова или в скобках.
    *   Удаляет кавычки (`QUOTES_PATTERN`).
    *   Удаляет лишние пробелы.
    *   Возвращает очищенное имя (в UPPERCASE для ЮЛ/ГОС) или `None`, если результат невалиден.
*   **`format_fio_display`:** Форматирует строку (предположительно ФИО) в вид "Фамилия И.О.".
*   **`normalize_and_classify`:** Оркестрирует вызов `detect_final_legal_form` и `normalize_name_core`, обрабатывает случай неудачной нормализации ядра.

### 4.5. Генерация Отчетов (`src/reporting.py`)

*   **`_prepare_final_cp_details`:** Финальная обработка данных контрагента перед рендерингом. Выбирает лучшее сырое имя (`get_best_name`), повторно вызывает `normalize_and_classify` для него, обрабатывает fallback-сценарии, форматирует `display_name` (для ФИО), формирует строки `raw_names_str` и `accounts_str`. Использует кэш `normalization_cache` для оптимизации.
*   **`generate_counterparty_annual_report_v5`:**
    *   Агрегирует `processed_transactions` в структуру `cp_aggregated_data` (словарь словарей), группируя по `cp_id`, затем по годам (`years`), затем по нашим организациям (`by_org`).
    *   Вызывает `_prepare_final_cp_details` для каждого контрагента.
    *   Формирует список словарей `report_data_json_list` для передачи в шаблон.
    *   Сериализует этот список в JSON (`report_data_json_string`).
    *   Рендерит шаблон `report_annual_template.html`.
*   **`generate_org_comparison_report_v5`:**
    *   Агрегирует `processed_transactions` в структуру `comparison_data`, группируя по `cp_id`, затем по нашим организациям (`interactions`), сохраняя типы операций (`types`), суммы и количество.
    *   Вызывает `_prepare_final_cp_details` для каждого контрагента.
    *   Формирует словарь `processed_comparison_data`.
    *   Сортирует его по ключам (имени контрагента) для передачи в шаблон.
    *   Готовит список ОПФ (`legal_forms`) и список наших организаций (`our_org_names`) для фильтров в шаблоне.
    *   Рендерит шаблон `report_comparison_template.html`.

### 4.6. Клиентская Логика Отчетов (JavaScript в HTML)

*   **Общее:** Используются jQuery и DataTables.js. Локализация встроена в HTML.
*   **Годовой отчет (`report_annual_template.html`):**
    *   Загружает данные из JSON (`#reportData`).
    *   Инициализирует DataTables без пагинации.
    *   Использует кастомный рендер для колонки "Контрагент" (`formatDisplayName`) для отображения ОПФ/ФИО и подсказки с сырыми именами.
    *   Реализует раскрытие дочерних строк (`formatChildRow`) по клику на `td.dt-control`.
    *   Настраивает сортировку числовых колонок с запятой.
*   **Отчет сравнения (`report_comparison_template.html`):**
    *   Инициализирует DataTables без пагинации.
    *   **Фильтрация:** Реализована через кастомную функцию поиска `$.fn.dataTable.ext.search.push`.
        *   Фильтры собираются из чекбоксов/радиокнопок в объект `filters`.
        *   Функция поиска для каждой строки (`tr`) читает ее `data-*` атрибуты (`data-legal-form`, `data-has-income`, `data-has-expense`, `data-interacted-orgs`) с помощью `.attr()`.
        *   Применяются последовательные проверки: ОПФ (с учетом правила "ДРУГОЕ"), Тип операций (логика ИЛИ, если выбраны оба), "Работал только с".
        *   Функция возвращает `true` (показать строку) или `false` (скрыть).
        *   Функция `applyFilters()` обновляет объект `filters` и вызывает `table.draw()` для перерисовки.

## 5. Конфигурация (`src/config.py`)

*   `DEBUG_MODE`: Включает/выключает режим отладки (логирование DEBUG в файл, генерация `debug_*.csv`).
*   `DATA_DIR`, `OUTPUT_DIR`, `TEMPLATES_DIR`: Пути к папкам.
*   `FILE_ENCODING`: Кодировка входных `.txt` файлов (важно для корректного чтения).
*   Имена выходных файлов отчетов и отладочных файлов.

## 6. Замечания и Потенциальные Улучшения

*   **Чувствительность нормализации:** Качество нормализации сильно зависит от регулярных выражений в `TRASH_PATTERNS_SPECIFIC`. Добавление или изменение правил может потребовать тщательного тестирования. Файл `debug_names.csv` (в DEBUG_MODE) помогает в этом.
*   **Определение ОПФ:** Алгоритм старается быть точным, но в сложных или нестандартных случаях может ошибаться.
*   **Производительность:** На очень больших объемах данных (сотни тысяч транзакций) агрегация в Python может занимать заметное время.
*   **Обработка ошибок парсинга:** `parser_1c.py` пытается обрабатывать ошибки чтения/кодировки, но нестандартный формат файла может вызвать проблемы.
*   **Клиентская фильтрация:** Вся фильтрация в отчете сравнения происходит в браузере. При очень большом количестве контрагентов (десятки тысяч) это может замедлять работу интерфейса.